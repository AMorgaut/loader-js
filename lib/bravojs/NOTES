
The notes below were generated by Christoph Dorn while working on the package & mappings support.

Links
-----

  * http://code.google.com/p/bravojs/
  * http://www.page.ca/~wes/CommonJS/modules-2.0-draft8/
  * http://wiki.commonjs.org/wiki/Packages/1.1
  * http://wiki.commonjs.org/wiki/Packages/Mappings/C

Overall
-------

  * Nice and mostly complete implementation that is relatively easy to follow.
  * Adding package & mappings support required non-trivial changes in more than a few places.
  * Some changes could be baked into the architecture of the loader better to maybe simplify and speed things us.
  * Module provider plugins via module.constructor.prototype are less useful as only one plugin will work at a time.
    Using hooks to trigger plugins may be more useful in various cases.
  * Package & mappings support should be recommended as a default feature for all CommonJS loaders to encourage
    interoperability of non-trivial module sets combined via packages into programs.

Questions
---------

  * When are module.eventually() callbacks called and for what purpose?
  * What is the difference now between the following. Are they all valid by default? Should they be?
      module.declare([], function(require, exports, module) {}) vs
      module.declare(function(require, exports, module) {}) vs
      No module.declare() i.e. Modules 1.1.1

Limitations
-----------

  * Only catalog-based (via plugin) and relative location path-based package mappings are supported at this time.

TODO
----

  * Loader plugins? See: http://wiki.commonjs.org/wiki/Modules/LoaderPlugin
  * Sandboxes to allow for arbitrary sub-program scopes within programs
  * nodejs support to provide module environment on server (like nodules: https://github.com/kriszyp/nodules)

Changes, Additions & Comments
-----------------------------

  * All internal top-level module paths for packaged modules follow <packageID>!/<modulePath> where '!/' is used to signify the package root.
  * Expanded scope of module.load(s, f) to allow a mappings object for 's'.
  * Expanded scope of module.declare([], f) to allow labelled mapping objects for '[]'.
  * Changed module.load(id/mapping, function(id) { ... }) to return the canonical ID of the loaded module that can be used with require(id).
  * Added chained plugin system to service resolvePackageMapping(packageMapping) which must return a top-level package ID if it can resolve.
  * Added module.pkgId which is set to the ID of the containing package for a module if the module is part of a package.
  * Added module.mappings which is set to a resolved map where values are top-level package IDs for a module if the module is part of a package with mappings.
  * Map package UID as valid package ID (in addition to path-basd package ID) if package descriptor has uid property set.   
  * Ability to resolve modules by <packageUID>!/<modulePath> if the package descriptor has the "uid" property set.
    e.g. require("http://registry/hostname/path/package1/!/lib/main")
    This is not ideal as one must know the *<modulePath>* in this case 'lib/main'. A better solution may be:
      require("http://registry/hostname/path/package1/!/").resolve("main");
    Where '!/' is used to signify that we want to load a special object that can resolve IDs for the specified package ID.
  * Relative dependency IDs for module.declare() were resolved based on bravojs.mainModuleDir whereas they should be resolved based on the path of the module.
